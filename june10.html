<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="staple.css">
    <link rel="icon" href="cuffee.png" type="image/x-icon">
    <link rel="stylesheet" href="dark-mode.css" id="dark-mode-stylesheet" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
    <title>Melancholy Mornings</title>

</head>
<body>
    <section class="whole">
        <div class="container">
            <div class="menu">
                <a href="../index.html" class="menu-link">Home</a>
                <div class="toggle-icon" id="dark-mode-toggle"><i class="fa-solid fa-moon" ></i></div> 
                <a href="" class="menu-link">Menu</a>
                
              </div>

              <section class="two">
              
                <div class="actual-container">
                    <div class="progress-bar"></div>
    
                        <h1 class="title">Day 1 - Implementing the Room Entity in Awa</h1>

                        <div class="about">
                            <p>Olaoluwa Oke| 19 June 2025 </p>
                            </div>

                        
                                
                                
                               <div class="datap">
                                <br> 
                                There’s a concept in HCI called an interface metaphor. 
                                It’s when you design something in code that mimics how things work in real life, 
                                so people don’t have to re-learn everything from scratch
                                <br> <br>

                                <li style="font-family: 'Cardo', serif;">A name and Unique ID . (Most houses don’t, but this one needs to.).</li>       
        <li style="font-family: 'Cardo', serif;">An owner or overseer. Someone who started the space and carries a small sense of responsibility for it</li> 
        <li style="font-family: 'Cardo', serif;">Members. Those who share the space.</li>
        <li style="font-family: 'Cardo', serif;">A key — in this case, an invite code. Something readable, not just a long random hash.</li>
        <li style="font-family: 'Cardo', serif;">And finally, a timestamp — the moment the space came into existence.</li>

        <br> <br>
        That mental model turned into code. The ownerId points to the user who created the room. The memberIds list contains all participants. The inviteCode works like a key to get in , generated to be short and human-friendly.

<br> <br>

<h3 style="font-family: 'Cardo', serif;">Technical Architecture — Room Entity Implementation</h3>
<br>
<h4 style="font-family: 'Cardo', serif;">1. Entity Definition</h4>
<h5 style="font-family: 'Cardo', serif;">Collection: rooms</h5>
<h5>Fields:</h5>

<li style="font-family: 'Cardo', serif;">id (String, primary key, auto-generated by MongoDB)</li>
<li style="font-family: 'Cardo', serif;">ownerId (String, references users.id)</li>
<li style="font-family: 'Cardo', serif;">memberIds (List <%String>, references users.id)</li>
<li style="font-family: 'Cardo', serif;">inviteCode (String, unique, 6-digits)</li>
<li style="font-family: 'Cardo', serif;">createdAt (Instant, auto-generated)</li>

<br> <br>
<h4 style="font-family: 'Cardo', serif;">2. Invite Code Utility</h4>  
<pre style="background-color: #f5f5f5; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px; color: #333; overflow-x: auto;">
fun generateInviteCode(length: Int = 6): String {
    val chars = ('a'..'z') + ('0'..'9')
    return (1..length).map { chars.random() }.joinToString("")
}
</pre>
<br> 

<h4 style="font-family: 'Cardo', serif;">3. Repository Layer</h4>

<li style="font-family: 'Cardo', serif;">Generates a random alphanumeric code of specified length.</li>
<li style="font-family: 'Cardo', serif;">Designed for readability and shareability (avoids special characters or uppercase).</li>

<br> 
<pre style="background-color: #f5f5f5; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px; color: #333; overflow-x: auto;">
interface RoomRepository : MongoRepository<Room, String> {
    fun findByInviteCode(inviteCode: String): Room?
}
</pre> <br> <br>
<li style="font-family: 'Cardo', serif;">Extends MongoRepository<%Room, String>.</li>
<li style="font-family: 'Cardo', serif;">Adds findByInviteCode() for lookup during join operations.</li>

<br> <br>

<h4 style="font-family: 'Cardo', serif;">4. Service Layer — Join Room Flow</h4>
<h5>joinRoom(userId: String, inviteCode: String)</h5>

<ol>
    <li style="font-family: 'Cardo', serif;">Fetch room via findByInviteCode(inviteCode).</li>
    <li style="font-family: 'Cardo', serif;">If no room found → throw RoomNotFoundException.</li>
    <li style="font-family: 'Cardo', serif;">Append userId to memberIds.</li>
    <li style="font-family: 'Cardo', serif;">Save updated room.</li>
    <li style="font-family: 'Cardo', serif;">Save updated room.</li>

</ol>

<br>

<pre style="background-color: #f5f5f5; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px; color: #333; overflow-x: auto;">
After testing, I realized this wasn’t the smartest approach. 
Keeping a memberIds array in the Room collection meant updating two collections for 
every join operation(tight coupling). It was simpler 
and more consistent to just give each User a roomId field and query membership from there.
</pre>

<br> <br>

<h5>Problem With This Design</h5>
<li style="font-family: 'Cardo', serif;">Fetch room via findByInviteCode(inviteCode).</li>
    <li style="font-family: 'Cardo', serif;">Tight Coupling: Membership state lived inside both Room and User, forcing 
        the system to maintain consistency across two collections.</li>
    <li style="font-family: 'Cardo', serif;">Dual Writes: Any join operation required updating both entities in sequence, introducing the 
        possibility of write skew or partial updates if one write failed.</li>
    <li style="font-family: 'Cardo', serif;">SData Redundancy: Membership info was
         duplicated, violating single source of truth principles.</li>
    <li style="font-family: 'Cardo', serif;">Query Complexity: Determining membership from the Room side meant scanning 
        embedded arrays, which becomes inefficient as membership scales</li>

        <br> <br>




<pre style="background-color: #f5f5f5; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px; color: #333; overflow-x: auto;">
fun joinRoom(userId: String, joinCode: String): UserResponse {
    val room = roomRepository.findByCode(joinCode)
        ?: throw NotFoundException("Room with code $joinCode not found")

    val user = userRepository.findById(ObjectId(userId))
        .orElseThrow { NotFoundException("User not found") }

    // already in a room?
    if (user.roomId != null) {
        throw AlreadyExistsException("User is already in a room")
    }

    // get users already in the room
    val usersInRoom = userRepository.findByRoomId(room.id!!)
    val roleToAssign = if (usersInRoom.isEmpty()) Role.OWNER else Role.MEMBER

    val updated = user.copy(
        roomId = room.id,
        role = roleToAssign
    )
    return userRepository.save(updated).toDTO()
}

</pre>

<br>
<h5> 6. Security Considerations</h5>
<li style="font-family: 'Cardo', serif;">Invite codes are unique and short-lived in future versions (TTL index).</li>
    <li style="font-family: 'Cardo', serif;">Only authenticated users can create or join rooms</li>
    <li style="font-family: 'Cardo', serif;">Owner field is immutable post-creation.</li>


<br> <br>
Next step is to implement all the controller endpoints


    
                
                
            </div>
    
        </section>   
        
        <script>
            const darkModeToggle = document.getElementById('dark-mode-toggle');
            const darkModeStylesheet = document.getElementById('dark-mode-stylesheet');
        
            darkModeToggle.addEventListener('click', () => {
                const isDarkModeEnabled = darkModeStylesheet.disabled;
                darkModeStylesheet.disabled = !isDarkModeEnabled;
            });
        </script>

        <section class="footer">
            <div class="numpage">
                <p class="num">Page 1 of 1</p>
                <p>© Olaoluwa</p>
                <!---<hr class="ubad">---->
    
                
            </div>
            <a title="Google Analytics Alternative" href="https://clicky.com/101412980"><img alt="Clicky" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
            <script async data-id="101412980" src="//static.getclicky.com/js"></script>