<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="staple.css">
    <link rel="icon" href="cuffee.png" type="image/x-icon">
    <link rel="stylesheet" href="dark-mode.css" id="dark-mode-stylesheet" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
    <title> HexDump & HollyWood</title>

</head>
<body>
    <section class="whole">
        <div class="container">
            <div class="menu">
                <a href="../index.html" class="menu-link">Home</a>
                <div class="toggle-icon" id="dark-mode-toggle"><i class="fa-solid fa-moon" ></i></div> 
                <a href="" class="menu-link">Menu</a>
                
              </div>

              <section class="two">
              
                <div class="actual-container">
                    <div class="progress-bar"></div>
    
                        <h1 class="title">Day 2 (Part 1)  - User Entity, Password Encoder , BcryptPasswordEncoder</h1>
                        
                        <div class="about">
                            <p>Olaoluwa Oke| 14 June 2023 </p>
                            </div>
                            <div class="data">
                                <p class="datap">
                                  I think I must’ve skipped over the User entity in my earlier notes. 
                                  That’s probably because I wrote it on Day One — fast. Mostly because
                                   I had already written something nearly identical
                                    for my bookmarking app, Tabitha.The style carried over nicely. And with the ERD already sketched out, this really wasn’t uncharted territory.
                                    

                                    <br> <br>
                                    The model is intentionally plain: identity, contact, auth, membership, lifecycle.
                                    <br> <br>
                                    Auth is next on the runway, so I wanted the substrate ready: stable fields, predictable lookups, and password handling that won’t make future-me wince.
    
                               <div class="datap">
                               <br> <br>
                               The User entity is pretty standard: <br>

                               </p>
<hr>
                               <h4>Technical Log</h4>
                               <h5>(1) Domain Model</h5>



                               <code>id</code>
                               <code>firstName</code>
                               <code>email</code>
                               <code>password</code>
                               <code>roomid</code>
                               <code>role</code>
                               <code>joinedAt</code>
                               <code>isActive</code>
                             
                               <br> <br>

                               <pre style="background-color: #f5f5f5; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px; color: #333; overflow-x: auto;">enum class Role { OWNER, MEMBER }</pre>



                               <h4>2. Repository Layer</h4>

                               <br>

                               <pre style="background-color: #f5f5f5; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 14px; color: #333; overflow-x: auto;">interface UserRepository : MongoRepository<%User, String> {
    fun findByEmailIgnoreCase(email: String): User?
    fun findByRoomId(roomId: String): List<%User>
}
</pre>

                               <br> <br>
 <li style="font-family: 'Cardo', serif;">findByEmailIgnoreCase backs login flows and signup duplicate checks.</li>
 <li style="font-family: 'Cardo', serif;">findByRoomId powers room membership views and role computations (e.g., first joiner = OWNER).</li>
 <br> <br>

  <h4>(3) Password Handling (BCrypt)</h4>
   <li style="font-family: 'Cardo', serif;">Store only one-way hashes (BCrypt). No reversible encoding, no salts managed by you—BCrypt handles per-hash salts and cost factor..</li>
    <li style="font-family: 'Cardo', serif;">Minimal API surface in a PasswordService:</li>
    encode(raw: String): String <br>
    matches(raw: String, hash: String): Boolean <br> <br>

    Rationale : 
    <li style="font-family: 'Cardo', serif;">Resistant to rainbow tables and supports work factor tuning (cost) as hardware improves.</li>
    <li style="font-family: 'Cardo', serif;">Keeps auth concerns cohesive and testable, separate from controllers/services.</li>
 <br> <br>

  <h4>(4) DTOs (Auth-Adjacent)</h4> <br>
<li style="font-family: 'Cardo', serif;">UserCreateRequest(firstName, email, password) → input</li>
<li style="font-family: 'Cardo', serif;">UserResponse(id, firstName, email, roomId, role, joinedAt, isActive) → output</li>
<li style="font-family: 'Cardo', serif;">(Auth-specific DTOs will arrive with the auth feature: LoginRequest, AuthResponse w/ JWT.)</li>

 <br>
  Principles
  <li style="font-family: 'Cardo', serif;"> Prevent overexposure of internals (never leak password/hash).</li>
   <li style="font-family: 'Cardo', serif;">Keep API contracts stable while entities evolve.</li>

<br> <br>
<h4>(5) Service Layer (UserService)</h4>
Injected deps: UserRepository, RoomRepository (see note below).
<br>
 <li style="font-family: 'Cardo', serif;"> createUser(req: UserCreateRequest): UserResponse</li>
    Lowercase + validate email, enforce uniqueness, password = bcrypt.encode(...), default isActive = true, role = MEMBER, joinedAt = now()
<li style="font-family: 'Cardo', serif;"> deactivateUser(userId): Unit → sets isActive = false (idempotent).</li>
<li style="font-family: 'Cardo', serif;">updateUser(userId, patch): UserResponse → constrained fields (no direct role escalations here).</li>
<li style="font-family: 'Cardo', serif;">getUsersInRoom(roomId): List<%UserResponse></li>
<li style="font-family: 'Cardo', serif;">joinRoom(userId, code): UserResponse</li>
Guards: user not already in a room; room exists; assign Role.OWNER if first member else MEMBER; single write to User (no dual writes) <br>
Uses userRepository.findByRoomId(room.id) to determine role.
<br> <br>
Why inject RoomRepository here?

<li style="font-family: 'Cardo', serif;">The join flow needs to resolve and validate the target room by code/ID and may apply future room-level invariants (e.g., capacity, status, invite TTL). Keeping that lookup centralized in the service avoids controller-level anemic logic and keeps business rules cohesive.</li> <br>
<li style="font-family: 'Cardo', serif;">More in the next entry when auth & room constraints kick in.</li>

<br> <br>

<h4>(6) Validation & Errors</h4>
<li style="font-family: 'Cardo', serif;">Email format + normalization (lowercase).</li>
<li style="font-family: 'Cardo', serif;">Unique email → map duplicate key to 409.</li>
<li style="font-family: 'Cardo', serif;">Not found → 404; already in a room → 409.</li>
<li style="font-family: 'Cardo', serif;">Centralized via @ControllerAdvice returning a compact error payload.</li>

 <br> <br>
<h4>(7) Security Posture (pre-auth)</h4>
<li style="font-family: 'Cardo', serif;">Never return password or security-adjacent fields in responses.</li>
<li style="font-family: 'Cardo', serif;">Start failing closed: endpoints require auth once JWT lands; until then, keep mutation endpoints behind a temporary gate (e.g., dev profile).</li>





    
                                <div style="width:10 0%; height:0; padding-bottom:55%; position:relative;">
  <img src="images/image-4.png" alt="ERD image" style="position:absolute; width:100%; height:100%; object-fit:cover;">
</div>
                                 <br>


                                 <code></code>

                               
                               
    
                                <br> <br>
                                
    
                                        </code>
                                   
                                            
                                             
                            <hr>
                            
                </div>
    
                <script>
                    const darkModeToggle = document.getElementById('dark-mode-toggle');
                    const darkModeStylesheet = document.getElementById('dark-mode-stylesheet');
                
                    darkModeToggle.addEventListener('click', () => {
                        const isDarkModeEnabled = darkModeStylesheet.disabled;
                        darkModeStylesheet.disabled = !isDarkModeEnabled;
                    });
                </script>
                
            </div>
    
        </section>           

        <section class="footer">
            <div class="numpage">
                <p class="num">Page 1 of 1</p>
                <p>© Word Aglow Parish 2023</p>
                <!---<hr class="ubad">---->
    
                
            </div>
            <a title="Google Analytics Alternative" href="https://clicky.com/101412980"><img alt="Clicky" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
            <script async data-id="101412980" src="//static.getclicky.com/js"></script>